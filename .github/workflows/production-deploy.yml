name: Production Deployment

on:
  push:
    branches: [ prod ]
  workflow_dispatch:
    inputs:
      app_version:
        description: 'Application version (Docker image tag)'
        required: false
        default: 'latest'
      helm_version:
        description: 'Helm chart version'
        required: false
        default: 'latest'
      namespace:
        description: 'Kubernetes namespace'
        required: false
        default: 'production'
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CHART_NAME: go-app

permissions:
  contents: read
  packages: read
  id-token: write

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      app_version: ${{ steps.versions.outputs.app_version }}
      helm_version: ${{ steps.versions.outputs.helm_version }}
      namespace: ${{ steps.versions.outputs.namespace }}
      environment: ${{ steps.versions.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine versions and settings
      id: versions
      run: |
        # Determine app version
        if [ "${{ github.event.inputs.app_version }}" != "" ]; then
          APP_VERSION="${{ github.event.inputs.app_version }}"
        else
          APP_VERSION="${GITHUB_SHA::7}"
        fi
        echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

        # Determine Helm version
        if [ "${{ github.event.inputs.helm_version }}" != "" ]; then
          HELM_VERSION="${{ github.event.inputs.helm_version }}"
        else
          HELM_VERSION=$(cat .github/helm-version.txt)
        fi
        echo "helm_version=$HELM_VERSION" >> $GITHUB_OUTPUT

        # Determine namespace
        NAMESPACE="${{ github.event.inputs.namespace || 'production' }}"
        echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

        # Determine environment
        ENV="${{ github.event.inputs.environment || 'production' }}"
        echo "environment=$ENV" >> $GITHUB_OUTPUT

        echo "Deployment Configuration:"
        echo "  App Version: $APP_VERSION"
        echo "  Helm Version: $HELM_VERSION"
        echo "  Namespace: $NAMESPACE"
        echo "  Environment: $ENV"

  build-docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: prepare
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ needs.prepare.outputs.app_version }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.app_version }}
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [prepare, build-docker]
    if: always() && needs.prepare.result == 'success' && (needs.build-docker.result == 'success' || needs.build-docker.result == 'skipped')
    environment:
      name: ${{ needs.prepare.outputs.environment }}
      url: https://myapp.example.com

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Helm
      uses: azure/setup-helm@v4
      with:
        version: 'latest'

    - name: Set up kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: 'latest'

    # Configure your Kubernetes cluster access here
    # This is a placeholder - adjust based on your cloud provider
    - name: Configure Kubernetes access
      run: |
        # Example for cloud providers:

        # AWS EKS:
        # aws eks update-kubeconfig --name my-cluster --region us-east-1

        # GKE:
        # gcloud container clusters get-credentials my-cluster --region us-central1

        # Azure AKS:
        # az aks get-credentials --resource-group my-rg --name my-cluster

        # For this example, we'll assume KUBECONFIG is provided as a secret
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
        echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
      env:
        KUBECONFIG: ${{ secrets.KUBECONFIG }}

    - name: Create namespace if not exists
      run: |
        kubectl create namespace ${{ needs.prepare.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Log in to Helm registry
      run: |
        echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

    - name: Pull Helm chart
      run: |
        helm pull oci://${{ env.REGISTRY }}/${{ github.repository_owner }}/charts/${{ env.CHART_NAME }} \
          --version ${{ needs.prepare.outputs.helm_version }} \
          --untar \
          --untardir /tmp

    - name: Prepare values file
      run: |
        cat > /tmp/deploy-values.yaml <<EOF
        image:
          repository: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tag: "${{ needs.prepare.outputs.app_version }}"
          pullPolicy: Always

        imagePullSecrets:
          - name: ghcr-secret

        replicaCount: 3

        autoscaling:
          enabled: true
          minReplicas: 3
          maxReplicas: 20
          targetCPUUtilizationPercentage: 70
          targetMemoryUtilizationPercentage: 75

        resources:
          limits:
            cpu: 1000m
            memory: 1Gi
          requests:
            cpu: 500m
            memory: 512Mi

        podDisruptionBudget:
          enabled: true
          minAvailable: 2

        serviceMonitor:
          enabled: true
          interval: 15s

        env:
          - name: ENVIRONMENT
            value: "${{ needs.prepare.outputs.environment }}"
          - name: PORT
            value: "8080"
          - name: HOST
            value: "0.0.0.0"
        EOF

    - name: Create image pull secret
      run: |
        kubectl create secret docker-registry ghcr-secret \
          --docker-server=${{ env.REGISTRY }} \
          --docker-username=${{ github.actor }} \
          --docker-password=${{ secrets.GITHUB_TOKEN }} \
          --namespace=${{ needs.prepare.outputs.namespace }} \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy with Helm
      run: |
        helm upgrade --install ${{ env.CHART_NAME }} /tmp/${{ env.CHART_NAME }} \
          --namespace ${{ needs.prepare.outputs.namespace }} \
          --values /tmp/deploy-values.yaml \
          --wait \
          --timeout 10m \
          --atomic \
          --cleanup-on-fail

    - name: Verify deployment
      run: |
        echo "Checking deployment status..."
        kubectl rollout status deployment/${{ env.CHART_NAME }} -n ${{ needs.prepare.outputs.namespace }} --timeout=5m

        echo "Checking pods..."
        kubectl get pods -n ${{ needs.prepare.outputs.namespace }} -l app.kubernetes.io/name=${{ env.CHART_NAME }}

        echo "Checking HPA..."
        kubectl get hpa -n ${{ needs.prepare.outputs.namespace }} -l app.kubernetes.io/name=${{ env.CHART_NAME }}

    - name: Run smoke tests
      run: |
        # Port forward to test health endpoints
        kubectl port-forward -n ${{ needs.prepare.outputs.namespace }} svc/${{ env.CHART_NAME }} 8080:80 &
        PF_PID=$!
        sleep 5

        # Test health endpoints
        echo "Testing health endpoints..."
        curl -f http://localhost:8080/health || exit 1
        curl -f http://localhost:8080/health/ready || exit 1
        curl -f http://localhost:8080/health/live || exit 1

        # Clean up port forward
        kill $PF_PID

        echo "Smoke tests passed!"

    - name: Get deployment info
      run: |
        echo "### Deployment Information" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Namespace:** ${{ needs.prepare.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
        echo "**App Version:** ${{ needs.prepare.outputs.app_version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Helm Chart Version:** ${{ needs.prepare.outputs.helm_version }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Deployment Status:**" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        kubectl get deployment -n ${{ needs.prepare.outputs.namespace }} -l app.kubernetes.io/name=${{ env.CHART_NAME }} >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Pods:**" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        kubectl get pods -n ${{ needs.prepare.outputs.namespace }} -l app.kubernetes.io/name=${{ env.CHART_NAME }} >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [prepare, deploy-to-kubernetes]
    if: always()

    steps:
    - name: Deployment Success Notification
      if: needs.deploy-to-kubernetes.result == 'success'
      run: |
        echo "Deployment to ${{ needs.prepare.outputs.environment }} was successful!"
        # Add your notification logic here (Slack, email, etc.)

    - name: Deployment Failure Notification
      if: needs.deploy-to-kubernetes.result == 'failure'
      run: |
        echo "Deployment to ${{ needs.prepare.outputs.environment }} failed!"
        # Add your notification logic here (Slack, email, etc.)
